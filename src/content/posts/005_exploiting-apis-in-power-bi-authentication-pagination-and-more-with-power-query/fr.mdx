---
title: "Exploiter les API dans Power BI : Authentification, Pagination et plus encore avec Power Query"
description: "A ajouter une description - Exploiter les API dans Power BI"
pubDate: "Jun 09 2025"
tags: ["Power BI", "Power Query", "API", "Authentification", "Pagination"]
lang: "fr"
heroImage: "https://github.com/user-attachments/assets/7df5048d-ffd0-4a30-9cb0-7ff7320a15cd"
giscusTitleDiscussionsMapping: "Flexible Data Source Management in Power BI with MySQL"
---

import Link from "@src/components/Link.astro";
import Note from "@src/components/Note.astro";

### Table des matières

- [Introduction](#introduction)
- [Conclusion](#conclusion)

<br />
### Introduction

L'intégration de données provenant d'une API REST est une étape courante dans Power BI, mais elle peut parfois s'avérer complexe. L'authentification, les en-têtes, la pagination... autant de défis à surmonter. Dans cet article, je vais vous montrer, étape par étape, comment importer des données depuis une API dans Power BI en utilisant Power Query, en gérant l'authentification JWT et la pagination. Nous utiliserons l'API <Link href="https://dummyjson.com" external>DummyJSON</Link> comme exemple, une API simple et gratuite, qui répond idéalement à nos besoins. Enfin, je pars du principe que vous maîtrisez déjà l’interface de Power BI Desktop et l’éditeur Power Query, ainsi que les notions essentielles liées aux API REST (GET, POST, en-têtes, JSON).

### Exploration de l'API DummyJSON

Avant de plonger dans le code Power Query, je vous propose de bien comprendre le fonctionnement de l’API que nous allons utiliser. Comme mentionné dans l’introduction, nous allons travailler avec <Link href="https://dummyjson.com" external>DummyJSON</Link>, une ressource idéale qui fournit des données factices au format JSON pour différents types d’entités (produits, utilisateurs, articles, etc.). Elle simule également des mécanismes typiques des API REST, tels que l’authentification et la pagination. Pour récupérer les données depuis une API, voici les étapes à suivre :

![Schéma des étapes de récupération des données](https://github.com/user-attachments/assets/2418584b-c52b-46a7-9991-28f431bef14a)

**_Authentification :_**

1. Envoyer une requête (`POST /auth/login`) avec les identifiants : La première étape consiste à envoyer une requête POST à l'endpoint d'authentification de l'API (https://dummyjson.com/auth/login). Cette requête doit inclure les identifiants de l'utilisateur (nom d'utilisateur et mot de passe) dans le corps de la requête au format JSON. Par exemple :
   ```json
   {
     "username": "emilys",
     "password": "emilyspass"
   }
   ```
2. Recevoir une réponse contenant les jetons d'accès et de rafraîchissement : En réponse à cette requête, l'API renvoie un objet JSON contenant notamment un `accessToken` et un `refreshToken`. Ces jetons sont essentiels pour accéder aux autres endpoints protégés par authentification.

<br />

**_Récupération des Données Produits :_**

3. Envoyer une requête (`GET /auth/products`) avec le jeton d'accès (`accessToken`) dans l'en-tête : Une fois que vous avez obtenu le jeton d'accès, vous pouvez envoyer une requête `GET` à l'endpoint des produits (https://dummyjson.com/auth/products). Cette requête doit inclure le jeton d'accès dans l'en-tête Authorization sous la forme `Bearer accessToken`.
4. Recevoir les données produits au format JSON : L'API renvoie alors un objet JSON contenant la liste des produits ainsi que des informations sur la pagination comme `total`, `skip`, et `limit`.
   ```json
     {
       "products": [
         {
           "id": 1,
           "title": "iPhone 13 Pro",
           "description": "Latest iPhone model with advanced features",
           "category": "Electronics",
           "price": 999.99,
           "discountPercentage": 10.5,
           "rating": 4.7,
           "stock": 50,
           "tags": [
             "beauty"
           ],
           "brand": "Apple",
           "sku": "IPHONE13-PRO-256",
           "weight": 0.35,
           "dimensions": {
             "width": 10.5,
             "height": 5.2,
             "depth": 3.8
           },
           "warrantyInformation": "1 year limited warranty",
           "shippingInformation": "Free shipping for orders over $50",
           "availabilityStatus": "In Stock",
           "reviews": [
             {
               "rating": 4,
               "comment": "Great product, highly recommended",
               "date": "2023-05-15",
               "reviewerName": "John Doe",
               "reviewerEmail": "john.doe@example.com"
             }
           ],
           "returnPolicy": "30 days money back guarantee",
           "minimumOrderQuantity": 1,
           "meta": {
             "createdAt": "2023-05-15T10:30:00Z",
             "updatedAt": "2023-05-16T14:20:00Z",
             "barcode": "123456789012",
             "qrCode": "https://example.com/qr/product123"
           },
           "images": [
             "https://example.com/image.jpg"
           ],
           "thumbnail": "https://example.com/thumb.jpg"
         },
         ...
     ],
     "total": 80,
     "skip": 0,
     "limit": 20
   }
   ```

<br />

### Configuration des paramètres et des fonctions Power Query

Pour interagir proprement avec l'API, nous allons créer plusieurs paramètres/fonctions Power Query (language M).

#### 1. Configuration des paramètres globaux Power Query

La première étape consiste à définir des paramètres globaux dans Power Query. Cela permet de centraliser les configurations et de les modifier facilement sans toucher au code des fonctions.
Dans l'Éditeur Power Query, sous l'onglet `Accueil`, cliquez sur `Gérer les paramètres` > `Nouveau paramètre` et ajouter les paramètres ci-dessous :.

- `API_BASE_URL` :
  - `Description` : L'URL de base de l'API DummyJSON.
  - `Type` : Texte
  - `Valeur` : https://dummyjson.com
- `API_LOGIN_USERNAME` :
  - `Description` : Le nom d'utilisateur pour l'authentification.
  - `Type` : Texte
  - `Valeur` : emilys
- `API_LOGIN_PASSWORD` :
  - `Description` : Le mot de passe pour l'authentification.
  - `Type` : Texte
  - `Valeur` : emilyspass
- `API_PAGINATION_SKIP` :
  - `Description` : Paramètre de pagination par défaut pour le nombre d'éléments à ignorer.
  - `Type` : Nombre décimal
  - `Valeur` : 0
- `API_PAGINATION_LIMIT` :
  - `Description` : Le nombre d'éléments à récupérer par page.
  - `Type` : Nombre décimal
  - `Valeur` : 20

![Paramètres power query](https://github.com/user-attachments/assets/7fb091cc-b821-401d-b621-dc93c0bae3d9)

<br />

#### 2. Fonctions Utilitaires pour les Requêtes HTTP

Deuxièmes étape nous allons créer 4 fonctions utilitaires `GetHeaderParameters`, `GetQueryParameters`, `HttpClientGetRequest` et `HttpClientPostRequest` pour gérer les requêtes HTTP. Ces fonctions serviront de briques de base pour tous nos appels API. Toujours dans l'Éditeur Power Query, sous l'onglet `Accueil`, cliquez sur `Nouvelle source` > `Requête vide` et ajoutez les fonctions ci-dessous.

##### 2.1 `GetHeaderParameters` : Configurer les En-têtes de Base

Cette fonction simple prépare un enregistrement (record) avec les en-têtes HTTP communs, comme `Content-Type`. Elle peut accepter des en-têtes optionnels pour plus de flexibilité.

```powerquery title="GetHeadersParameters"
let
    GetHeadersParameters = (optional Headers as record) =>
        let
            Headers = Record.Combine({[
                #"Content-Type" = "application/json"
            ], (Headers ?? [])})
        in
            Headers
in
    GetHeadersParameters
```

##### 2.2 `GetQueryParameters` : Configurer les Paramètres de Requête pour la Pagination

Cette fonction aide à construire l'objet Query pour les appels API, en particulier pour les paramètres `skip` et `limit`.

```powerquery title="GetQueryParameters"
let
    GetQueryParameters = (optional Skip as number, optional Query as record) =>
        let
            Query = Record.Combine(
                {[
                    skip = Number.ToText(Skip ?? API_PAGINATION_SKIP),
                    limit = Number.ToText(API_PAGINATION_LIMIT)
                ], (Query ?? [])}
            )
        in
            Query
in
    GetQueryParameters
```

##### 2.3 `HttpClientGetRequest` : Gérer les Requêtes HTTP GET

Cette fonction générique envoie une requête GET vers l'API, en prenant en compte le chemin relatif, les paramètres de requête et les en-têtes. Elle utilise la fonction `Web.Contents` de Power Query pour effectuer l'appel HTTP avec l'URL de base `API_BASE_URL` définie précédemment et renvoie la réponse en JSON.

```powerquery title="HttpClientGetRequest"
let
    HttpClientGetRequest = (RelativePath as text, optional Query as record, optional Headers as record) =>
        let
            Options = [
                RelativePath = RelativePath,
                Query = (Query ?? []),
                Headers = (Headers ?? [])
            ],
            RawData = Web.Contents(API_BASE_URL, Options),
            Json = Json.Document(RawData)
        in
            Json
in
    HttpClientGetRequest
```

##### 2.4 `HttpClientPostRequest` : Gérer les Requêtes HTTP POST

Similaire à la fonction précédente, mais pour les requêtes POST, qui incluent souvent un corps (`Body`). Lorsqu'un corps de requête est ajouté, la fonction `Web.Contents` transforme automatiquement la requête en POST comme mentionné dans la <Link href="https://learn.microsoft.com/fr-fr/powerquery-m/web-contents" external>documentation</Link>.

```powerquery title="HttpClientPostRequest"
let
    HttpClientPostRequest = (
        RelativePath as text, optional Query as record, optional Headers as record, optional Body as record
    ) =>
        let
            Options = [
                RelativePath = RelativePath,
                Query = (Query ?? []),
                Headers = (Headers ?? []),
                Content = Json.FromValue(Body ?? [])
            ],
            RawData = Web.Contents(API_BASE_URL, Options),
            Json = Json.Document(RawData)
        in
            Json
in
    HttpClientPostRequest
```

<Note>
  Vous avez peut-être remarqué que les fonctions `HttpClientGetRequest` et `HttpClientPostRequest` sont similaires. La principale différence est que `HttpClientPostRequest` reçoit un paramètre `Body` et l'ajoute dans l'option `Content` de la fonction `Web.Contents`. Vous vous demandez peut-être pourquoi ne pas combiner les deux fonctions en une seule. Je comprends et je me suis posé la même question et j'ai tenté de créer une seule fonction HttpClient, comme illustré ci-dessous.

  <details>
    <summary>Fonction Générique `HttpClient` :</summary>

    ```powerquery title="HttpClient"
    let
        HttpClient = (
            RelativePath as text, optional Query as record, optional Headers as record, optional Body as record
        ) =>
            let
                GetOptions = [
                    RelativePath = RelativePath,
                    Query = (Query ?? []),
                    Headers = (Headers ?? [])
                ],
                PostOptions = [
                    RelativePath = RelativePath,
                    Query = (Query ?? []),
                    Headers = (Headers ?? []),
                    Content = Json.FromValue(Body ?? [])
                ],
                Options = if Body <> null and Record.FieldCount(Body) > 0 then PostOptions else GetOptions,
                RawData = Web.Contents(API_BASE_URL, Options),
                Json = Json.Document(RawData)
            in
                Json
    in
        HttpClient
    ```

    Cette fonction fonctionne correctement et prend en charge les requêtes `GET` et `POST`. Cependant, il y a un problème. En effet, si vous consultez la fenêtre des options "Paramètres de la source de données" dans Power BI Desktop, un avertissement indique que certaines sources de données peuvent ne pas être affichées en raison de requêtes écrites manuellement. Cela est dû au fait que Power Query considère les options de la fonction `Web.Contents` comme dynamiques, car nous utilisons une condition pour choisir entre `GetOptions` et `PostOptions` en fonction du `Body`. Voici un exemple de l'avertissement que vous pourriez voir :

    ![Data source settings](https://github.com/user-attachments/assets/2636a861-6fc0-4504-bf18-19656618322b)

    Cet avertissement empêchera la planification de rafraîchissement dans le Power BI Service. Pour contourner ce problème, je n'ai pas d'autre solution que de séparer la fonction en deux fonctions distinctes : `HttpClientGetRequest` et `HttpClientPostRequest`.
    N'hésitez pas à me faire part de vos réflexions sur cette approche dans les commentaires ci-dessous. Je serais ravi d'en discuter avec vous ! 😊

  </details>
</Note>

<br />

#### 3. Gestion de l'Authentification

Maintenant, construisons les fonctions spécifiques à l'authentification JWT.

##### 3.1 `GetJwtTokens` : Obtenir les Jetons d'Authentification

Cette fonction envoie une requête `POST` à l'endpoint d'authentification `/auth/login` de l'API pour obtenir les jetons d'accès `accessToken` et de rafraîchissement `refreshToken`. Nous allons utiliser la fonction `HttpClientPostRequest` que nous avons créée précédemment.

```powerquery title="GetJwtTokens"
let
    GetJwtTokens = () =>
        let
            Headers = GetHeadersParameters(),
            Quey = [],
            Body = [
                username = API_LOGIN_USERNAME,
                password = API_LOGIN_PASSWORD
            ],
            Response = HttpClientPostRequest("auth/login", Quey, Headers, Body),
            JwtTokens = [
                accessToken = Record.Field(Response, "accessToken"),
                refreshToken = Record.Field(Response, "refreshToken")
            ]
        in
            JwtTokens
in
    GetJwtTokens
```

##### 3.2 `GetHeadersParametersWithAccessToken` : Ajouter le Jeton JWT aux En-têtes

Cette fonction étend `GetHeadersParameters` en intégrant un jeton JWT aux en-têtes HTTP. Elle commence par obtenir le jeton d'accès via `GetJwtTokens`, puis fusionne ce jeton avec les en-têtes existants. Ainsi, toutes les requêtes HTTP authentifiées contiennent le jeton d'accès requis pour l'autorisation.

```powerquery title="GetHeadersParametersWithAccessToken"
let
    GetHeadersParametersWithAccessToken = (optional Headers as record) =>
        let
            JwtToken = GetJwtTokens(),
            accessToken = Record.Field(JwtToken, "accessToken"),
            Headers = Record.Combine(
                {GetHeadersParameters((Headers ?? [])), [
                    Authorization = Text.Format("Bearer #{0}", {accessToken})
                ]}
            )
        in
            Headers
in
    GetHeadersParametersWithAccessToken
```

#### 4. Récupération des données et gestion de la pagination

Maintenant, nous allons créer la fonction principale `FetchDataFromApi`. Cette fonction sera responsable de l'ensemble de la logique nécessaire pour obtenir les données depuis l'API, y compris la gestion de la pagination.

```powerquery title="FetchDataFromApi"
let
    FetchDataFromApi = (RelativePath as text, ResultsFieldName as text, TotalFieldName as text) =>
        let
            // Function to get the total number from the API response
            RetrieveTotalCount = (FieldName as text) =>
            let
                ApiResponse = HttpClientGetRequest(
                    RelativePath, GetQueryParameters(), GetHeadersParametersWithAccessToken()
                ),
                TotalCount = Record.Field(ApiResponse, FieldName)
            in
                TotalCount,

            // Function to get a page based on the index
            FetchPage = (FieldName as text, PageIndex as number) =>
                let
                    Offset = (PageIndex ?? 0) * API_PAGINATION_LIMIT,
                    QueryParams = GetQueryParameters(Offset),
                    AuthHeaders = GetHeadersParametersWithAccessToken(),
                    ApiResponse = HttpClientGetRequest(RelativePath, QueryParams, AuthHeaders),
                    Results = Record.Field(ApiResponse, FieldName)
                in
                    Results,

            // Function to get all by iterating through pages
            GetAllData = () =>
                let
                    TotalProducts = RetrieveTotalCount(TotalFieldName),
                    MaxCount = List.Max({API_PAGINATION_LIMIT, TotalProducts}),
                    TotalPages = Number.RoundUp(MaxCount / API_PAGINATION_LIMIT),
                    PageIndices = {0..TotalPages - 1},
                    AllPages = List.Transform(PageIndices, each FetchPage(ResultsFieldName, _)),
                    CombinedPages = List.Union(AllPages),
                    DataTable = Table.FromList(CombinedPages, Splitter.SplitByNothing(), null, null, ExtraValues.Error),
                    ColumnIndices = List.Positions(Table.ColumnNames(DataTable)),
                    RecordColumnIndex = List.First(
                        List.Select(
                            ColumnIndices, each Type.Is(Value.Type(Record.FieldValues(DataTable{0}){_}), type record)
                        )
                    ),
                    RecordColumnName = Table.ColumnNames(DataTable){RecordColumnIndex},
                    RecordFieldNames = Record.FieldNames(Record.FieldValues(DataTable{0}){RecordColumnIndex}),
                    ExpandedTable = Table.ExpandRecordColumn(
                        DataTable, RecordColumnName, RecordFieldNames, RecordFieldNames
                    )
                in
                    ExpandedTable
        in
            GetAllData()
in
    FetchDataFromApi
```

Je ne vais pas entrer dans les détails de chaque ligne de code, je vous encourage à examiner le code pour bien comprendre son fonctionnement. Mais voici comment elle fonctionne en résumé :

1. **_Elle a besoin de savoir où chercher_** : Vous lui donnez le chemin spécifique de l'API `RelativePath`, le nom du champ dans la réponse de l'API qui contient la liste des résultats `ResultsFieldName`, et le nom du champ qui indique le nombre total d'éléments disponibles `TotalFieldName`.
2. **_Compter le total_** : D'abord, elle fait un premier appel à l'API juste pour savoir combien il y a d'éléments au total à récupérer. C'est comme regarder le nombre total de pages dans un livre. 🔢
3. **_Récupérer page par page_** : Ensuite, sachant combien d'éléments il y a et combien d'éléments sont affichés par page (grâce au paramètre `API_PAGINATION_LIMIT`), elle calcule le nombre de pages à aller chercher. Puis, elle demande à l'API chaque page, l'une après l'autre, en utilisant les fonctions d'authentification et de requête que nous avons définies plus tôt. 🚶‍♀️🚶‍♂️
4. **_Tout rassembler_** : Une fois que toutes les pages de données ont été récupérées, elle les combine en une seule grande liste. ➕
5. **_Transformer en tableau propre_** : Finalement, cette liste est transformée en un tableau Power Query. Si les données de chaque page sont des enregistrements (comme des lignes avec plusieurs colonnes d'informations), elle détecte automatiquement cette structure et déplie ces enregistrements pour que chaque information ait sa propre colonne. 📊

En gros, `FetchDataFromApi` s'occupe de tout le travail de pagination pour vous donner un tableau unique et complet avec toutes les données de l'API. ✨

#### 5. Enregistrer les fonctions dans Power Query

Une fois que vous avez créé toutes les fonctions, assurez-vous de les enregistrer dans Power Query. Vous pouvez le faire sous l'onglet `Accueil`, cliquez sur `Nouvelle source` > `Requête vide dans l'Éditeur Power Query. Puis ouvrez l'éditeur avancé et collez le code de chaque fonction. N'oubliez pas de nommer chaque fonction correctement pour qu'elles soient facilement identifiables.

Par example pour la fonction `GetHeadersParameters` :

![GetHeadersParameters function](https://github.com/user-attachments/assets/986f278f-83b1-41d1-8872-d35f646cbf5f)

Je vous laisse ajouter les autres fonctions de la même manière. Vous pouvez également créer des dossiers dans l'éditeur Power Query pour organiser vos paramètres et fonctions. Cela vous aidera à garder votre projet propre et bien structuré.

![Project file structure](https://github.com/user-attachments/assets/e444438f-4049-44dc-b3d4-7ba0a02e5cbc)

### Importation des données dans Power BI (Utilisation de la fonction `FetchDataFromApi`)

Maintenant que nous avons configuré toutes les fonctions nécessaires, il est temps de les utiliser pour importer les données des produits dans Power BI.
Pour importer les données des produits, nous allons utiliser la fonction `FetchDataFromApi` que nous avons créée précédemment. Créez une nouvelle requête vide dans l'Éditeur Power Query, puis ouvrez l'éditeur avancé et collez le code suivant :

```powerquery title="Products"
let
    Source = FetchDataFromApi("auth/products", "products", "total")
in
    Source
```

![Powerquery code for products query](https://github.com/user-attachments/assets/98112183-8faa-45f5-9195-aefa07a85ba7)

Cette requête appelle la fonction `FetchDataFromApi` avec les paramètres appropriés pour récupérer les données des produits. Le premier paramètre est le chemin relatif de l'API pour les produits `"auth/products"`, le deuxième est le nom du champ dans la réponse qui contient la liste des produits `"products"`, et le troisième est le nom du champ qui indique le nombre total de produits `"total"`. N'oubliez pas de cliquer sur `Terminer` pour charger les données dans Power BI.

![Products query](https://github.com/user-attachments/assets/7860a108-f550-472c-b548-6162fb55bb72)

De la même manière, si vous souhaitez importer les données des utilisateurs, la démarche sera quasiment identique.

```powerquery title="Users"
let
    Source = FetchDataFromApi("auth/users", "users", "total")
in
    Source
```

C'est simple n'est ce pas ? 😎

<Note variant='tip'>
  Le schéma ci-dessous montre la vue des dépendances de requêtes (Query Dependencies) dans Power Query. Il permet de visualiser comment les différentes fonctions et requêtes interagissent entre elles. C’est un excellent moyen de comprendre la structure de ton projet, de repérer les relations entre les éléments, et de t'assurer que tout est bien connecté.

![Query Dependencies](https://github.com/user-attachments/assets/12c9c406-b640-46d5-9268-c4a73518954b)

</Note>
